
#
# WepSIM (https://wepsim.github.io/wepsim/)
#

begin,
native
{
                  if (simcore_native_get_signal("INT") == 1)
                  {
                        // RT1 <- MBR <- DB <- INTV
                        var value  = simcore_native_get_value("CPU", "INTV") ;
                        simcore_native_set_value("CPU", "REG_RT1", value) ;

                        // INT down, INTA up
                        simcore_native_set_signal("INT",  0) ;
                        simcore_native_set_signal("INTA", 1) ;

                        // push PC
                        value  = simcore_native_get_value("CPU", "REG_PC") ;
                        var reg_sp = simcore_native_get_value("BR", 29) ;
                        reg_sp = reg_sp - 4 ;
                        simcore_native_set_value("MEMORY", reg_sp, value) ;
                        simcore_native_set_value("BR", 29, reg_sp) ;

                        // push SR
                        value  = simcore_native_get_value("CPU", "REG_SR") ;
                        reg_sp = simcore_native_get_value("BR", 29) ;
                        reg_sp = reg_sp - 4 ;
                        simcore_native_set_value("MEMORY", reg_sp, value) ;
                        simcore_native_set_value("BR", 29, reg_sp) ;

                        // MAR <- RT1*4
                        var addr = simcore_native_get_value("CPU", "REG_RT1") ;
                        addr = 4 * addr ;
                        simcore_native_set_value("CPU", "REG_MAR", addr) ;

                        // PC <- MBR <- MP[MAR]
                        addr = simcore_native_get_value("MEMORY", addr) ;
                        simcore_native_set_value("CPU", "REG_PC", addr) ;

                        // fetch
                        simcore_native_go_maddr(0) ;
                }

                var addr  = simcore_native_get_value("CPU", "REG_PC") ;
                var value = simcore_native_get_value("MEMORY", addr) ;

                simcore_native_set_value("CPU", "REG_IR", value) ;
                simcore_native_set_value("CPU", "REG_PC", addr + 4) ;

                simcore_native_deco() ;
                simcore_native_go_opcode() ;
}


#
# INT
#

syscall {
            co=111111,
            nwords=1,
            native,
            {
                        simcore_native_set_value("CPU", "REG_RT1", 2) ;

                        // push PC
                        var value  = simcore_native_get_value("CPU", "REG_PC") ;
                        var reg_sp = simcore_native_get_value("BR", 29) ;
                        reg_sp = reg_sp - 4 ;
                        simcore_native_set_value("MEMORY", reg_sp, value) ;
                        simcore_native_set_value("BR", 29, reg_sp) ;

                        // push SR
                        value  = simcore_native_get_value("CPU", "REG_SR") ;
                        reg_sp = simcore_native_get_value("BR", 29) ;
                        reg_sp = reg_sp - 4 ;
                        simcore_native_set_value("MEMORY", reg_sp, value) ;
                        simcore_native_set_value("BR", 29, reg_sp) ;

                        // MAR <- RT1*4
                        var addr = simcore_native_get_value("CPU", "REG_RT1") ;
                        addr = 4 * addr ;
                        simcore_native_set_value("CPU", "REG_MAR", addr) ;

                        // PC <- MBR <- MP[MAR]
                        addr = simcore_native_get_value("MEMORY", addr) ;
                        simcore_native_set_value("CPU", "REG_PC", addr) ;

                        // fetch
                        simcore_native_go_maddr(0) ;
            }
}

reti {
            co=111111,
            nwords=1,
            native,
            {
                // pop SR
                var reg_sp = simcore_native_get_value("BR", 29) ;
                var value  = simcore_native_get_value("MEMORY", reg_sp) ;
                reg_sp = reg_sp + 4 ;
                simcore_native_set_value("CPU", "REG_SR", value) ;
                simcore_native_set_value("BR", 29, reg_sp) ;

                // pop PC
                var reg_sp = simcore_native_get_value("BR", 29) ;
                var value  = simcore_native_get_value("MEMORY", reg_sp) ;
                reg_sp = reg_sp + 4 ;
                simcore_native_set_value("CPU", "REG_PC", value) ;
                simcore_native_set_value("BR", 29, reg_sp) ;

                simcore_native_go_maddr(0) ;
            }
}


#
# IN/OUT
#

in reg val {
            co=111111,
            nwords=1,
            reg=reg(25,21),
            val=inm(15,0),
            native,
            {
                // fields is a default parameter with the instruction field information
                var reg1   = simcore_native_get_field_from_ir(fields, 0) ;
                var addr   = simcore_native_get_field_from_ir(fields, 1) ;

                var value = simcore_native_get_value("DEVICE", addr) ;
                simcore_native_set_value("BR", reg1, value) ;

                simcore_native_go_maddr(0) ;
            }
}

out reg val {
            co=111111,
            nwords=1,
            reg=reg(25,21),
            val=inm(15,0),
            native,
            {
                // fields is a default parameter with the instruction field information
                var reg1   = simcore_native_get_field_from_ir(fields, 0) ;
                var addr   = simcore_native_get_field_from_ir(fields, 1) ;

                var value = simcore_native_get_value("BR", reg1) ;
                simcore_native_set_value("DEVICE", addr, value) ;

                simcore_native_go_maddr(0) ;
            }
}


#
# https://rv8.io/isa.html
# RV32I
#

#  LUI rd,imm 	Load Upper Immediate 			rd ← imm
lui rd inm {
            co=111111,
            nwords=1,
            rd=reg(25,21),
            inm=inm(15,0),
            native,
            {
                // fields is a default parameter with the instruction field information
                var reg1   = simcore_native_get_field_from_ir(fields, 0) ;
                var val1   = simcore_native_get_field_from_ir(fields, 1) ;

                if (val1 & 0x00008000)
                    val1 = val1 | 0xFFFF0000 ;
                simcore_native_set_value("BR", reg1, val1) ;

                simcore_native_go_maddr(0) ;
            }
}

#  AUIPC rd,offset 	Add Upper Immediate to PC 	rd ← pc + offset
auipc rd offset {
            co=111111,
            nwords=1,
            rd=reg(25,21),
            offset=inm(15,0),
            native,
            {
                // fields is a default parameter with the instruction field information
                var reg1   = simcore_native_get_field_from_ir(fields, 0) ;
                var val1   = simcore_native_get_field_from_ir(fields, 1) ;

                if (val1 & 0x00008000)
                    val1 = val1 | 0xFFFF0000 ;
		var reg_pc = simcore_native_get_value("CPU", "REG_PC") ;
                simcore_native_set_value("BR", reg1, reg_pc + val1) ;

                simcore_native_go_maddr(0) ;
            }
}

#  JAL rd,offset 	Jump and Link 				rd ← pc + length(inst)
#                       					pc ← pc + offset
jal rd offset {
            co=111111,
            nwords=1,
            rd=reg(25,21),
            offset=address(15,0)abs,
            native,
            {
                // fields is a default parameter with the instruction field information
                var rd     = simcore_native_get_field_from_ir(fields, 0) ;
                var offset = simcore_native_get_field_from_ir(fields, 1) ;

                var pc = simcore_native_get_value("CPU", "REG_PC") ;
                simcore_native_set_value("BR", rd, pc) ;
                simcore_native_set_value("CPU", "REG_PC", pc + offset) ;

                simcore_native_go_maddr(0) ;
            }
}


#  JALR rd,rs1,offset 	Jump and Link Register 			rd ← pc + length(inst)
#                      						pc ← (rs1 + offset) ∧ -2
jalr rd rs1 offset {
            co=111111,
            nwords=1,
            rd=reg(25,21),
            rs1=reg(20,16),
            offset=address(15,0)abs,
            native,
            {
                // fields is a default parameter with the instruction field information
                var rd     = simcore_native_get_field_from_ir(fields, 0) ;
                var rs1    = simcore_native_get_field_from_ir(fields, 1) ;
                var offset = simcore_native_get_field_from_ir(fields, 2) ;

                var pc = simcore_native_get_value("CPU", "REG_PC") ;
                simcore_native_set_value("BR", rd, pc) ;
                simcore_native_set_value("CPU", "REG_PC", (rs1 + offset) & 0xFFFFFFFE) ;

                simcore_native_go_maddr(0) ;
            }
}

#  BEQ rs1,rs2,offset 	Branch Equal 				if rs1 = rs2 then pc ← pc + offset
beq rs1 rs2 offset {
            co=111111,
            nwords=1,
            rs1=reg(25,21),
            rs2=reg(20,16),
            offset=address(15,0)rel,
            native,
            {
                // fields is a default parameter with the instruction field information
                var reg1   = simcore_native_get_field_from_ir(fields, 0) ;
                var reg2   = simcore_native_get_field_from_ir(fields, 1) ;
                var offset = simcore_native_get_field_from_ir(fields, 2) ;

                reg1 = simcore_native_get_value("BR", reg1) ;
                reg2 = simcore_native_get_value("BR", reg2) ;
                if (reg1 == reg2)
                {
                    var pc = simcore_native_get_value("CPU", "REG_PC") ;
                    if ((offset & 0x8000) > 0)
                         offset = offset | 0xFFFF0000 ;
                    pc = pc + offset ;
                    simcore_native_set_value("CPU", "REG_PC", pc) ;
                }

                simcore_native_go_maddr(0) ;
            }
}

#  BNE rs1,rs2,offset 	Branch Not Equal 			if rs1 ≠ rs2 then pc ← pc + offset
bne rs1 rs2 offset {
            co=111111,
            nwords=1,
            rs1=reg(25,21),
            rs2=reg(20,16),
            offset=address(15,0)rel,
            native,
            {
                // fields is a default parameter with the instruction field information
                var reg1   = simcore_native_get_field_from_ir(fields, 0) ;
                var reg2   = simcore_native_get_field_from_ir(fields, 1) ;
                var offset = simcore_native_get_field_from_ir(fields, 2) ;

                reg1 = simcore_native_get_value("BR", reg1) ;
                reg2 = simcore_native_get_value("BR", reg2) ;
                if (reg1 != reg2)
                {
                    var pc = simcore_native_get_value("CPU", "REG_PC") ;
                    if ((offset & 0x8000) > 0)
                         offset = offset | 0xFFFF0000 ;
                    pc = pc + offset ;
                    simcore_native_set_value("CPU", "REG_PC", pc) ;
                }

                simcore_native_go_maddr(0) ;
            }
}

#  BLT rs1,rs2,offset 	Branch Less Than 			if rs1 < rs2 then pc ← pc + offset
blt rs1 rs2 offset {
            co=111111,
            nwords=1,
            rs1=reg(25,21),
            rs2=reg(20,16),
            offset=address(15,0)rel,
            native,
            {
                // fields is a default parameter with the instruction field information
                var reg1   = simcore_native_get_field_from_ir(fields, 0) ;
                var reg2   = simcore_native_get_field_from_ir(fields, 1) ;
                var offset = simcore_native_get_field_from_ir(fields, 2) ;

                reg1 = simcore_native_get_value("BR", reg1) ;
                reg2 = simcore_native_get_value("BR", reg2) ;
                if (reg1 < reg2)
                {
                    var pc = simcore_native_get_value("CPU", "REG_PC") ;
                    if ((offset & 0x8000) > 0)
                         offset = offset | 0xFFFF0000 ;
                    pc = pc + offset ;
                    simcore_native_set_value("CPU", "REG_PC", pc) ;
                }

                simcore_native_go_maddr(0) ;
            }
}

#  BGE rs1,rs2,offset 	Branch Greater than Equal 		if rs1 ≥ rs2 then pc ← pc + offset
bge rs1 rs2 offset {
            co=111111,
            nwords=1,
            rs1=reg(25,21),
            rs2=reg(20,16),
            offset=address(15,0)rel,
            native,
            {
                // fields is a default parameter with the instruction field information
                var reg1   = simcore_native_get_field_from_ir(fields, 0) ;
                var reg2   = simcore_native_get_field_from_ir(fields, 1) ;
                var offset = simcore_native_get_field_from_ir(fields, 2) ;

                reg1 = simcore_native_get_value("BR", reg1) ;
                reg2 = simcore_native_get_value("BR", reg2) ;
                if (reg1 >= reg2)
                {
                    var pc = simcore_native_get_value("CPU", "REG_PC") ;
                    if ((offset & 0x8000) > 0)
                         offset = offset | 0xFFFF0000 ;
                    pc = pc + offset ;
                    simcore_native_set_value("CPU", "REG_PC", pc) ;
                }

                simcore_native_go_maddr(0) ;
            }
}

#  BLTU rs1,rs2,offset 	Branch Less Than Unsigned 		if rs1 < rs2 then pc ← pc + offset
bltu rs1 rs2 offset {
            co=111111,
            nwords=1,
            rs1=reg(25,21),
            rs2=reg(20,16),
            offset=address(15,0)rel,
            native,
            {
                // fields is a default parameter with the instruction field information
                var reg1   = simcore_native_get_field_from_ir(fields, 0) ;
                var reg2   = simcore_native_get_field_from_ir(fields, 1) ;
                var offset = simcore_native_get_field_from_ir(fields, 2) ;

                reg1 = simcore_native_get_value("BR", reg1) ;
                reg2 = simcore_native_get_value("BR", reg2) ;
                if (reg1 < reg2)
                {
                    var pc = simcore_native_get_value("CPU", "REG_PC") ;
                    if ((offset & 0x8000) > 0)
                         offset = offset | 0xFFFF0000 ;
                    pc = pc + offset ;
                    simcore_native_set_value("CPU", "REG_PC", pc) ;
                }

                simcore_native_go_maddr(0) ;
            }
}

#  BGEU rs1,rs2,offset 	Branch Greater than Equal Unsigned 	if rs1 ≥ rs2 then pc ← pc + offset
bgeu rs1 rs2 offset {
            co=111111,
            nwords=1,
            rs1=reg(25,21),
            rs2=reg(20,16),
            offset=address(15,0)rel,
            native,
            {
                // fields is a default parameter with the instruction field information
                var reg1   = simcore_native_get_field_from_ir(fields, 0) ;
                var reg2   = simcore_native_get_field_from_ir(fields, 1) ;
                var offset = simcore_native_get_field_from_ir(fields, 2) ;

                reg1 = simcore_native_get_value("BR", reg1) ;
                reg2 = simcore_native_get_value("BR", reg2) ;
                if (reg1 >= reg2)
                {
                    var pc = simcore_native_get_value("CPU", "REG_PC") ;
                    if ((offset & 0x8000) > 0)
                         offset = offset | 0xFFFF0000 ;
                    pc = pc + offset ;
                    simcore_native_set_value("CPU", "REG_PC", pc) ;
                }

                simcore_native_go_maddr(0) ;
            }
}

#  LB rd,offset(rs1) 	Load Byte 				rd ← s8[rs1 + offset]
lb rd offset(rs1) {
            co=111111,
            nwords=1,
            rd=reg(25,21),
            offset=inm(15,0),
            rs1=reg(20,16),
            native,
            {
                // fields is a default parameter with the instruction field information
                var rd     = simcore_native_get_field_from_ir(fields, 0) ;
                var offset = simcore_native_get_field_from_ir(fields, 1) ;
                var rs1    = simcore_native_get_field_from_ir(fields, 2) ;

                var b_addr = simcore_native_get_value("BR", rs1) + offset ;
                var w_addr = b_addr & 0xFFFFFFFC ;
                var w_value = simcore_native_get_value("MEMORY", w_addr) ;
                var  b_value = b_addr & 0x00000003 ;
                     b_value = w_value >>> (8 * b_value) ;
                if  (b_value & 0x00000080)
                     b_value = b_value | 0xFFFFFF00 ;
                else b_value = b_value & 0x000000FF ;
                simcore_native_set_value("BR", rd, b_value) ;

                simcore_native_go_maddr(0) ;
            }
}

#  LH rd,offset(rs1) 	Load Half 				rd ← s16[rs1 + offset]
lh rd offset(rs1) {
            co=111111,
            nwords=1,
            rd=reg(25,21),
            offset=inm(15,0),
            rs1=reg(20,16),
            native,
            {
                // fields is a default parameter with the instruction field information
                var rd     = simcore_native_get_field_from_ir(fields, 0) ;
                var offset = simcore_native_get_field_from_ir(fields, 1) ;
                var rs1    = simcore_native_get_field_from_ir(fields, 2) ;

                // TODO

                simcore_native_go_maddr(0) ;
            }
}

#  LW rd,offset(rs1) 	Load Word 				rd ← s32[rs1 + offset]
lw rd offset(rs1) {
            co=111111,
            nwords=1,
            rd=reg(25,21),
            offset=inm(15,0),
            rs1=reg(20,16),
            native,
            {
                // fields is a default parameter with the instruction field information
                var rd     = simcore_native_get_field_from_ir(fields, 0) ;
                var offset = simcore_native_get_field_from_ir(fields, 1) ;
                var rs1    = simcore_native_get_field_from_ir(fields, 2) ;

                var addr   = simcore_native_get_value("BR", rs1) + offset ;
                var value  = simcore_native_get_value("MEMORY", addr) ;
                simcore_native_set_value("BR", rd, value) ;

                simcore_native_go_maddr(0) ;
            }
}

#  LBU rd,offset(rs1) 	Load Byte Unsigned 			rd ← u8[rs1 + offset]
lbu rd offset(rs1) {
            co=111111,
            nwords=1,
            rd=reg(25,21),
            offset=inm(15,0),
            rs1=reg(20,16),
            native,
            {
                // fields is a default parameter with the instruction field information
                var rd     = simcore_native_get_field_from_ir(fields, 0) ;
                var offset = simcore_native_get_field_from_ir(fields, 1) ;
                var rs1    = simcore_native_get_field_from_ir(fields, 2) ;

                var addr   = simcore_native_get_value("BR", rs1) + offset ;
                var value  = simcore_native_get_value("MEMORY", addr) ;
                    value  = value & 0x000000FF ;
                simcore_native_set_value("BR", rd, value) ;

                simcore_native_go_maddr(0) ;
            }
}

#  LHU rd,offset(rs1) 	Load Half Unsigned 			rd ← u16[rs1 + offset]
lhu rd offset(rs1) {
            co=111111,
            nwords=1,
            rd=reg(25,21),
            offset=inm(15,0),
            rs1=reg(20,16),
            native,
            {
                // fields is a default parameter with the instruction field information
                var rd     = simcore_native_get_field_from_ir(fields, 0) ;
                var offset = simcore_native_get_field_from_ir(fields, 1) ;
                var rs1    = simcore_native_get_field_from_ir(fields, 2) ;

                // TODO

                simcore_native_go_maddr(0) ;
            }
}

#  SB rs2,offset(rs1) 	Store Byte 				u8[rs1 + offset] ← rs2
sb rs2 offset(rs1) {
            co=111111,
            nwords=1,
            rs2=reg(25,21),
            offset=inm(15,0),
            rs1=reg(20,16),
            native,
            {
                // fields is a default parameter with the instruction field information
                var rs2    = simcore_native_get_field_from_ir(fields, 0) ;
                var offset = simcore_native_get_field_from_ir(fields, 1) ;
                var rs1    = simcore_native_get_field_from_ir(fields, 2) ;

                var b_addr  = simcore_native_get_value("BR", rs1) + offset ;
                var b_value = simcore_native_get_value("BR", rs2) ;
                    b_value = b_value & 0x000000FF ;
                var w_addr  = b_addr & 0xFFFFFFFC ;
                var w_value = simcore_native_get_value("MEMORY", w_addr) ;
                var b_off   = b_addr & 0x00000003 ;
                if (3 == b_off) w_value = (w_value & 0x00FFFFFF) | (b_value << 24) ;
                if (2 == b_off) w_value = (w_value & 0xFF00FFFF) | (b_value << 16) ;
                if (1 == b_off) w_value = (w_value & 0xFFFF00FF) | (b_value <<  8) ;
                if (0 == b_off) w_value = (w_value & 0xFFFFFF00) | (b_value) ;
                simcore_native_set_value("MEMORY", w_addr, w_value) ;

                simcore_native_go_maddr(0) ;
            }
}

#  SH rs2,offset(rs1) 	Store Half 				u16[rs1 + offset] ← rs2
sh rs2 offset(rs1) {
            co=111111,
            nwords=1,
            rs2=reg(25,21),
            offset=inm(15,0),
            rs1=reg(20,16),
            native,
            {
                // fields is a default parameter with the instruction field information
                var rs2    = simcore_native_get_field_from_ir(fields, 0) ;
                var offset = simcore_native_get_field_from_ir(fields, 1) ;
                var rs1    = simcore_native_get_field_from_ir(fields, 2) ;

                var b_addr  = simcore_native_get_value("BR", rs1) + offset ;
                var b_value = simcore_native_get_value("BR", rs2) ;

                var value_1 = b_value & 0x000000FF ;
                var w_addr  = b_addr & 0xFFFFFFFC ;
                var w_value = simcore_native_get_value("MEMORY", w_addr) ;
                var b_off   = b_addr & 0x00000003 ;
                if (3 == b_off) w_value = (w_value & 0x00FFFFFF) | (value_1 << 24) ;
                if (2 == b_off) w_value = (w_value & 0xFF00FFFF) | (value_1 << 16) ;
                if (1 == b_off) w_value = (w_value & 0xFFFF00FF) | (value_1 <<  8) ;
                if (0 == b_off) w_value = (w_value & 0xFFFFFF00) | (value_1) ;
                simcore_native_set_value("MEMORY", w_addr, w_value) ;

                value_1 = b_value & 0x0000FF00 ;
                value_1 = value_1 >> 16 ;
                w_addr  = (b_addr + 1) & 0xFFFFFFFC ;
                w_value = simcore_native_get_value("MEMORY", w_addr) ;
                b_off   = b_addr & 0x00000003 ;
                if (3 == b_off) w_value = (w_value & 0x00FFFFFF) | (value_1 << 24) ;
                if (2 == b_off) w_value = (w_value & 0xFF00FFFF) | (value_1 << 16) ;
                if (1 == b_off) w_value = (w_value & 0xFFFF00FF) | (value_1 <<  8) ;
                if (0 == b_off) w_value = (w_value & 0xFFFFFF00) | (value_1) ;
                simcore_native_set_value("MEMORY", w_addr, w_value) ;

                simcore_native_go_maddr(0) ;
            }
}

#  SW rs2,offset(rs1) 	Store Word 				u32[rs1 + offset] ← rs2
sw reg1 val(reg2) {
            co=111111,
            nwords=1,
            reg1 = reg(25,21),
            val  = inm(15,0),
            reg2 = reg(20,16),
            native,
            {
                // fields is a default parameter with the instruction field information
                var reg1   = simcore_native_get_field_from_ir(fields, 0) ;
                var val    = simcore_native_get_field_from_ir(fields, 1) ;
                var reg2   = simcore_native_get_field_from_ir(fields, 2) ;

                var addr   = simcore_native_get_value("BR", reg2) + val ;
                var value1 = simcore_native_get_value("BR", reg1) ;
                simcore_native_set_value("MEMORY", addr, value1) ;

                simcore_native_go_maddr(0) ;
            }
}

#  ADDI rd,rs1,imm 	Add Immediate 				rd ← rs1 + sx(imm)
addi rd rs1 inm {
            co=111111,
            nwords=1,
            rd=reg(25,21),
            rs1=reg(20,16),
            inm =inm(15,0),
            native,
            {
                // fields is a default parameter with the instruction field information
                var reg1   = simcore_native_get_field_from_ir(fields, 0) ;
                var reg2   = simcore_native_get_field_from_ir(fields, 1) ;
                var val    = simcore_native_get_field_from_ir(fields, 2) ;

                var result = simcore_native_get_value("BR", reg2) + val ;
                simcore_native_set_value("BR", reg1, result) ;

                simcore_native_go_maddr(0) ;
            }
}

#  SLTI rd,rs1,imm 	Set Less Than Immediate 		rd ← sx(rs1) < sx(imm)
slti rd rs1 inm {
            co=111111,
            nwords=1,
            rd=reg(25,21),
            rs1=reg(20,16),
            inm=inm(15,0),
            native,
            {
                // fields is a default parameter with the instruction field information
                var rd   = simcore_native_get_field_from_ir(fields, 0) ;
                var rs1  = simcore_native_get_field_from_ir(fields, 1) ;
                var inm1 = simcore_native_get_field_from_ir(fields, 2) ;

                var reg1 = simcore_native_get_value("BR", rs1) ;
                           simcore_native_set_value("BR", rd, (reg1 < inm1)) ;

                simcore_native_go_maddr(0) ;
            }
}

#  SLTIU rd,rs1,imm 	Set Less Than Immediate Unsigned 	rd ← ux(rs1) < ux(imm)
sltiu rd rs1 inm {
            co=111111,
            nwords=1,
            rd=reg(25,21),
            rs1=reg(20,16),
            inm=inm(15,0),
            native,
            {
                // fields is a default parameter with the instruction field information
                var rd   = simcore_native_get_field_from_ir(fields, 0) ;
                var rs1  = simcore_native_get_field_from_ir(fields, 1) ;
                var inm1 = simcore_native_get_field_from_ir(fields, 2) ;

                var reg1 = simcore_native_get_value("BR", rs1) ;
                           simcore_native_set_value("BR", rd, (Math.abs(reg1) < Math.abs(inm1))) ;

                simcore_native_go_maddr(0) ;
            }
}

#  XORI rd,rs1,imm 	Xor Immediate 				rd ← ux(rs1) ⊕ ux(imm)
xori rd rs1 inm {
            co=111111,
            nwords=1,
            rd=reg(25,21),
            rs1=reg(20,16),
            inm =inm(15,0),
            native,
            {
                // fields is a default parameter with the instruction field information
                var reg1   = simcore_native_get_field_from_ir(fields, 0) ;
                var reg2   = simcore_native_get_field_from_ir(fields, 1) ;
                var val    = simcore_native_get_field_from_ir(fields, 2) ;

                var result = simcore_native_get_value("BR", reg2) ^ val ;
                simcore_native_set_value("BR", reg1, result) ;

                simcore_native_go_maddr(0) ;
            }
}

#  ORI rd,rs1,imm 	Or Immediate 				rd ← ux(rs1) ∨ ux(imm)
ori rd rs1 inm {
            co=111111,
            nwords=1,
            rd=reg(25,21),
            rs1=reg(20,16),
            inm =inm(15,0),
            native,
            {
                // fields is a default parameter with the instruction field information
                var reg1   = simcore_native_get_field_from_ir(fields, 0) ;
                var reg2   = simcore_native_get_field_from_ir(fields, 1) ;
                var val    = simcore_native_get_field_from_ir(fields, 2) ;

                var result = simcore_native_get_value("BR", reg2) | val ;
                simcore_native_set_value("BR", reg1, result) ;

                simcore_native_go_maddr(0) ;
            }
}

#  ANDI rd,rs1,imm 	And Immediate 				rd ← ux(rs1) ∧ ux(imm)
andi rd rs1 inm {
            co=111111,
            nwords=1,
            rd=reg(25,21),
            rs1=reg(20,16),
            inm =inm(15,0),
            native,
            {
                // fields is a default parameter with the instruction field information
                var reg1   = simcore_native_get_field_from_ir(fields, 0) ;
                var reg2   = simcore_native_get_field_from_ir(fields, 1) ;
                var val    = simcore_native_get_field_from_ir(fields, 2) ;

                var result = simcore_native_get_value("BR", reg2) + val ;
                simcore_native_set_value("BR", reg1, result) ;

                simcore_native_go_maddr(0) ;
            }
}

#  SLLI rd,rs1,imm 	Shift Left Logical Immediate 		rd ← ux(rs1) « ux(imm)
slli rd rs1 inm {
            co=111111,
            nwords=1,
            rd=reg(25,21),
            rs1=reg(20,16),
            inm=inm(5,0),
            native,
            {
                // fields is a default parameter with the instruction field information
                var reg1 = simcore_native_get_field_from_ir(fields, 0) ;
                var reg2 = simcore_native_get_field_from_ir(fields, 1) ;
                var val1 = simcore_native_get_field_from_ir(fields, 2) ;

                var result = simcore_native_get_value("BR", reg2) << val1 ;
                simcore_native_set_value("BR", reg1, result) ;

                simcore_native_go_maddr(0) ;
            }
}


#  SRLI rd,rs1,imm 	Shift Right Logical Immediate 		rd ← ux(rs1) » ux(imm)
srli rd rs1 inm {
            co=111111,
            nwords=1,
            rd=reg(25,21),
            rs1=reg(20,16),
            inm=inm(5,0),
            native,
            {
                // fields is a default parameter with the instruction field information
                var reg1 = simcore_native_get_field_from_ir(fields, 0) ;
                var reg2 = simcore_native_get_field_from_ir(fields, 1) ;
                var val1 = simcore_native_get_field_from_ir(fields, 2) ;

                var result = simcore_native_get_value("BR", reg2) >>> val1 ;
                simcore_native_set_value("BR", reg1, result) ;

                simcore_native_go_maddr(0) ;
            }
}

#  SRAI rd,rs1,imm 	Shift Right Arithmetic Immediate 	rd ← sx(rs1) » ux(imm)
srai rd rs1 inm {
            co=111111,
            nwords=1,
            rd=reg(25,21),
            rs1=reg(20,16),
            inm=inm(15,0),
            native,
            {
                // fields is a default parameter with the instruction field information
                var reg1 = simcore_native_get_field_from_ir(fields, 0) ;
                var reg2 = simcore_native_get_field_from_ir(fields, 1) ;
                var inm1 = simcore_native_get_field_from_ir(fields, 2) ;

                var val1 = simcore_native_get_value("BR", reg2) ;
                simcore_native_set_value("BR", reg1, val1 >> inm1) ;

                simcore_native_go_maddr(0) ;
            }
}

#  ADD rd,rs1,rs2 	Add 					rd ← sx(rs1) + sx(rs2)
add reg1 reg2 reg3 {
            co=111111,
            nwords=1,
            reg1=reg(25,21),
            reg2=reg(20,16),
            reg3=reg(15,11),
            native,
            {
                // fields is a default parameter with the instruction field information
                var reg1   = simcore_native_get_field_from_ir(fields, 0) ;
                var reg2   = simcore_native_get_field_from_ir(fields, 1) ;
                var reg3   = simcore_native_get_field_from_ir(fields, 2) ;

                var result = simcore_native_get_value("BR", reg2) + simcore_native_get_value("BR", reg3) ;
                simcore_native_set_value("BR", reg1, result) ;

                simcore_native_go_maddr(0) ;
            }
}

#  SUB rd,rs1,rs2 	Subtract 				rd ← sx(rs1) - sx(rs2)
sub reg1 reg2 reg3 {
            co=111111,
            nwords=1,
            reg1=reg(25,21),
            reg2=reg(20,16),
            reg3=reg(15,11),
            native,
            {
                // fields is a default parameter with the instruction field information
                var reg1   = simcore_native_get_field_from_ir(fields, 0) ;
                var reg2   = simcore_native_get_field_from_ir(fields, 1) ;
                var reg3   = simcore_native_get_field_from_ir(fields, 2) ;

                var result = simcore_native_get_value("BR", reg2) - simcore_native_get_value("BR", reg3) ;
                simcore_native_set_value("BR", reg1, result) ;

                simcore_native_go_maddr(0) ;
            }
}

#  SLL rd,rs1,rs2 	Shift Left Logical 			rd ← ux(rs1) « rs2
sll rd rs1 rs2 {
            co=111111,
            nwords=1,
            rd=reg(25,21),
            rs1=reg(20,16),
            rs2=reg(15,11),
            native,
            {
                // fields is a default parameter with the instruction field information
                var reg1   = simcore_native_get_field_from_ir(fields, 0) ;
                var reg2   = simcore_native_get_field_from_ir(fields, 1) ;
                var reg3   = simcore_native_get_field_from_ir(fields, 2) ;

                var result = simcore_native_get_value("BR", reg2) << simcore_native_get_value("BR", reg3) ;
                simcore_native_set_value("BR", reg1, result) ;

                simcore_native_go_maddr(0) ;
            }
}

#  SLT rd,rs1,rs2 	Set Less Than 				rd ← sx(rs1) < sx(rs2)
slt rd rs1 rs2 {
            co=111111,
            nwords=1,
            rd=reg(25,21),
            rs1=reg(20,16),
            rs2=reg(15,11),
            native,
            {
                // fields is a default parameter with the instruction field information
                var rd  = simcore_native_get_field_from_ir(fields, 0) ;
                var rs1 = simcore_native_get_field_from_ir(fields, 1) ;
                var rs2 = simcore_native_get_field_from_ir(fields, 2) ;

                var reg1 = simcore_native_get_value("BR", rs1) ;
                var reg2 = simcore_native_get_value("BR", rs2) ;
                           simcore_native_set_value("BR", rd, (reg1 < reg2)) ;

                simcore_native_go_maddr(0) ;
            }
}

#  SLTU rd,rs1,rs2 	Set Less Than Unsigned 			rd ← ux(rs1) < ux(rs2)
sltu rd rs1 rs2 {
            co=111111,
            nwords=1,
            rd=reg(25,21),
            rs1=reg(20,16),
            rs2=reg(15,11),
            native,
            {
                // fields is a default parameter with the instruction field information
                var rd  = simcore_native_get_field_from_ir(fields, 0) ;
                var rs1 = simcore_native_get_field_from_ir(fields, 1) ;
                var rs2 = simcore_native_get_field_from_ir(fields, 2) ;

                var reg1 = simcore_native_get_value("BR", rs1) ;
                var reg2 = simcore_native_get_value("BR", rs2) ;
                           simcore_native_set_value("BR", rd, (Math.abs(reg1) < Math.abs(reg2))) ;

                simcore_native_go_maddr(0) ;
            }
}

#  XOR rd,rs1,rs2 	Xor 					rd ← ux(rs1) ⊕ ux(rs2)
xor reg1 reg2 reg3 {
            co=111111,
            nwords=1,
            reg1=reg(25,21),
            reg2=reg(20,16),
            reg3=reg(15,11),
            native,
            {
                // fields is a default parameter with the instruction field information
                var reg1   = simcore_native_get_field_from_ir(fields, 0) ;
                var reg2   = simcore_native_get_field_from_ir(fields, 1) ;
                var reg3   = simcore_native_get_field_from_ir(fields, 2) ;

                var result = simcore_native_get_value("BR", reg2) ^ simcore_native_get_value("BR", reg3) ;
                simcore_native_set_value("BR", reg1, result) ;

                simcore_native_go_maddr(0) ;
            }
}

#  SRL rd,rs1,rs2 	Shift Right Logical 			rd ← ux(rs1) » rs2
srl rd rs1 rs2 {
            co=111111,
            nwords=1,
            rd=reg(25,21),
            rs1=reg(20,16),
            rs2=reg(15,11),
            native,
            {
                // fields is a default parameter with the instruction field information
                var reg1   = simcore_native_get_field_from_ir(fields, 0) ;
                var reg2   = simcore_native_get_field_from_ir(fields, 1) ;
                var reg3   = simcore_native_get_field_from_ir(fields, 2) ;

                var result = simcore_native_get_value("BR", reg2) >> simcore_native_get_value("BR", reg3) ;
                simcore_native_set_value("BR", reg1, result) ;

                simcore_native_go_maddr(0) ;
            }
}

#  SRA rd,rs1,rs2 	Shift Right Arithmetic 			rd ← sx(rs1) » rs2
sra rd rs1 rs2 {
            co=111111,
            nwords=1,
            rd=reg(25,21),
            rs1=reg(20,16),
            rs2=reg(15,11),
            native,
            {
                // fields is a default parameter with the instruction field information
                var reg1 = simcore_native_get_field_from_ir(fields, 0) ;
                var reg2 = simcore_native_get_field_from_ir(fields, 1) ;
                var reg3 = simcore_native_get_field_from_ir(fields, 2) ;

                var val1 = simcore_native_get_value("BR", reg2) ;
                var val2 = simcore_native_get_value("BR", reg3) ;
                simcore_native_set_value("BR", reg1, val1 >> val2) ;

                simcore_native_go_maddr(0) ;
            }
}

#  OR rd,rs1,rs2 	Or 					rd ← ux(rs1) ∨ ux(rs2)
or reg1 reg2 reg3 {
            co=111111,
            nwords=1,
            reg1=reg(25,21),
            reg2=reg(20,16),
            reg3=reg(15,11),
            native,
            {
                // fields is a default parameter with the instruction field information
                var reg1   = simcore_native_get_field_from_ir(fields, 0) ;
                var reg2   = simcore_native_get_field_from_ir(fields, 1) ;
                var reg3   = simcore_native_get_field_from_ir(fields, 2) ;

                var result = simcore_native_get_value("BR", reg2) | simcore_native_get_value("BR", reg3) ;
                simcore_native_set_value("BR", reg1, result) ;

                simcore_native_go_maddr(0) ;
            }
}

#  AND rd,rs1,rs2 	And 					rd ← ux(rs1) ∧ ux(rs2)
and reg1 reg2 reg3 {
            co=111111,
            nwords=1,
            reg1=reg(25,21),
            reg2=reg(20,16),
            reg3=reg(15,11),
            native,
            {
                // fields is a default parameter with the instruction field information
                var reg1   = simcore_native_get_field_from_ir(fields, 0) ;
                var reg2   = simcore_native_get_field_from_ir(fields, 1) ;
                var reg3   = simcore_native_get_field_from_ir(fields, 2) ;

                var result = simcore_native_get_value("BR", reg2) & simcore_native_get_value("BR", reg3) ;
                simcore_native_set_value("BR", reg1, result) ;

                simcore_native_go_maddr(0) ;
            }
}

#  FENCE pred,succ 	Fence 	
fence pred succ {
            co=111111,
            nwords=1,
            pred=inm(25,21),
            succ=inm(15,0),
            native,
            {
                // TODO

                simcore_native_go_maddr(0) ;
            }
}

#  FENCE.I 		Fence Instruction 	
fence.i {
            co=111111,
            nwords=1,
            native,
            {
                // TODO

                simcore_native_go_maddr(0) ;
            }
}


#
# https://rv8.io/isa.html
# RV32M
#

# MUL rd,rs1,rs2 	Multiply 	rd ← ux(rs1) × ux(rs2)
mul reg1 reg2 reg3 {
            co=111111,
            nwords=1,
            reg1=reg(25,21),
            reg2=reg(20,16),
            reg3=reg(15,11),
            native,
            {
                // fields is a default parameter with the instruction field information
                var reg1   = simcore_native_get_field_from_ir(fields, 0) ;
                var reg2   = simcore_native_get_field_from_ir(fields, 1) ;
                var reg3   = simcore_native_get_field_from_ir(fields, 2) ;

                var result = simcore_native_get_value("BR", reg2) * simcore_native_get_value("BR", reg3) ;
                simcore_native_set_value("BR", reg1, result) ;

                simcore_native_go_maddr(0) ;
            }
}

# MULH rd,rs1,rs2 	Multiply High Signed Signed 	rd ← (sx(rs1) × sx(rs2)) » xlen
mulh rd rs1 rs2 {
            co=111111,
            nwords=1,
            rd=reg(25,21),
            rs1=reg(20,16),
            rs2=reg(15,11),
            native,
            {
                // fields is a default parameter with the instruction field information
                var reg1   = simcore_native_get_field_from_ir(fields, 0) ;
                var reg2   = simcore_native_get_field_from_ir(fields, 1) ;
                var reg3   = simcore_native_get_field_from_ir(fields, 2) ;

                // TODO

                simcore_native_go_maddr(0) ;
            }
}

# MULHSU rd,rs1,rs2 	Multiply High Signed Unsigned 	rd ← (sx(rs1) × ux(rs2)) » xlen
mulhsu rd rs1 rs2 {
            co=111111,
            nwords=1,
            rd=reg(25,21),
            rs1=reg(20,16),
            rs2=reg(15,11),
            native,
            {
                // fields is a default parameter with the instruction field information
                var reg1   = simcore_native_get_field_from_ir(fields, 0) ;
                var reg2   = simcore_native_get_field_from_ir(fields, 1) ;
                var reg3   = simcore_native_get_field_from_ir(fields, 2) ;

                // TODO

                simcore_native_go_maddr(0) ;
            }
}

# MULHU rd,rs1,rs2 	Multiply High Unsigned Unsigned 	rd ← (ux(rs1) × ux(rs2)) » xlen
mulhu rd rs1 rs2 {
            co=111111,
            nwords=1,
            rd=reg(25,21),
            rs1=reg(20,16),
            rs2=reg(15,11),
            native,
            {
                // fields is a default parameter with the instruction field information
                var reg1   = simcore_native_get_field_from_ir(fields, 0) ;
                var reg2   = simcore_native_get_field_from_ir(fields, 1) ;
                var reg3   = simcore_native_get_field_from_ir(fields, 2) ;

                // TODO

                simcore_native_go_maddr(0) ;
            }
}

# DIV rd,rs1,rs2 	Divide Signed 	rd ← sx(rs1) ÷ sx(rs2)
div reg1 reg2 reg3 {
            co=111111,
            nwords=1,
            reg1=reg(25,21),
            reg2=reg(20,16),
            reg3=reg(15,11),
            native,
            {
                // fields is a default parameter with the instruction field information
                var reg1 = simcore_native_get_field_from_ir(fields, 0) ;
                var reg2 = simcore_native_get_field_from_ir(fields, 1) ;
                var reg3 = simcore_native_get_field_from_ir(fields, 2) ;

                if (simcore_native_get_value("BR", reg3) != 0)
                {
                    var val1 = simcore_native_get_value("BR", reg2) ;
                    var val2 = simcore_native_get_value("BR", reg3) ;
                    simcore_native_set_value("BR", reg1, val1 / val2) ;
                    simcore_native_set_value("BR", reg1, result) ;
                    simcore_native_go_maddr(0) ;
                    return ;
                }

		simcore_native_set_value("CPU", "REG_RT1", 1) ;

		// push PC
		var value  = simcore_native_get_value("CPU", "REG_PC") ;
		var reg_sp = simcore_native_get_value("BR", 29) ;
		reg_sp = reg_sp - 4 ;
		simcore_native_set_value("MEMORY", reg_sp, value) ;
		simcore_native_set_value("BR", 29, reg_sp) ;

		// push SR
		value  = simcore_native_get_value("CPU", "REG_SR") ;
		reg_sp = simcore_native_get_value("BR", 29) ;
		reg_sp = reg_sp - 4 ;
		simcore_native_set_value("MEMORY", reg_sp, value) ;
		simcore_native_set_value("BR", 29, reg_sp) ;

		// MAR <- RT1*4
		var addr = simcore_native_get_value("CPU", "REG_RT1") ;
		addr = 4 * addr ;
		simcore_native_set_value("CPU", "REG_MAR", addr) ;

		// PC <- MBR <- MP[MAR]
		addr = simcore_native_get_value("MEMORY", addr) ;
		simcore_native_set_value("CPU", "REG_PC", addr) ;

		// fetch
		simcore_native_go_maddr(0) ;
            }
}

# DIVU rd,rs1,rs2 	Divide Unsigned 	rd ← ux(rs1) ÷ ux(rs2)
divu rd rs1 rs2 {
            co=111111,
            nwords=1,
            rd=reg(25,21),
            rs1=reg(20,16),
            rs2=reg(15,11),
            native,
            {
                // fields is a default parameter with the instruction field information
                var reg1 = simcore_native_get_field_from_ir(fields, 0) ;
                var reg2 = simcore_native_get_field_from_ir(fields, 1) ;
                var reg3 = simcore_native_get_field_from_ir(fields, 2) ;

                if (simcore_native_get_value("BR", reg3) != 0)
                {
                    var val1 = simcore_native_get_value("BR", reg2) ;
                    var val2 = simcore_native_get_value("BR", reg3) ;
                    simcore_native_set_value("BR", reg1, Math.abs(val1) / Math.abs(val2)) ;
                    simcore_native_go_maddr(0) ;
                    return ;
                }

		simcore_native_set_value("CPU", "REG_RT1", 1) ;

		// push PC
		var value  = simcore_native_get_value("CPU", "REG_PC") ;
		var reg_sp = simcore_native_get_value("BR", 29) ;
		reg_sp = reg_sp - 4 ;
		simcore_native_set_value("MEMORY", reg_sp, value) ;
		simcore_native_set_value("BR", 29, reg_sp) ;

		// push SR
		value  = simcore_native_get_value("CPU", "REG_SR") ;
		reg_sp = simcore_native_get_value("BR", 29) ;
		reg_sp = reg_sp - 4 ;
		simcore_native_set_value("MEMORY", reg_sp, value) ;
		simcore_native_set_value("BR", 29, reg_sp) ;

		// MAR <- RT1*4
		var addr = simcore_native_get_value("CPU", "REG_RT1") ;
		addr = 4 * addr ;
		simcore_native_set_value("CPU", "REG_MAR", addr) ;

		// PC <- MBR <- MP[MAR]
		addr = simcore_native_get_value("MEMORY", addr) ;
		simcore_native_set_value("CPU", "REG_PC", addr) ;

		// fetch
		simcore_native_go_maddr(0) ;
            }
}

# REM rd,rs1,rs2 	Remainder Signed 	rd ← sx(rs1) mod sx(rs2)
rem reg1 reg2 reg3 {
            co=111111,
            nwords=1,
            reg1=reg(25,21),
            reg2=reg(20,16),
            reg3=reg(15,11),
            native,
            {
                // fields is a default parameter with the instruction field information
                var reg1   = simcore_native_get_field_from_ir(fields, 0) ;
                var reg2   = simcore_native_get_field_from_ir(fields, 1) ;
                var reg3   = simcore_native_get_field_from_ir(fields, 2) ;

                var val1 = simcore_native_get_value("BR", reg2) ;
                var val2 = simcore_native_get_value("BR", reg3) ;
                simcore_native_set_value("BR", reg1, val1 % val2) ;

                simcore_native_go_maddr(0) ;
            }
}

# REMU rd,rs1,rs2 	Remainder Unsigned 	rd ← ux(rs1) mod ux(rs2)
remu rd rs1 rs2 {
            co=111111,
            nwords=1,
            rd=reg(25,21),
            rs1=reg(20,16),
            rs2=reg(15,11),
            native,
            {
                // fields is a default parameter with the instruction field information
                var reg1   = simcore_native_get_field_from_ir(fields, 0) ;
                var reg2   = simcore_native_get_field_from_ir(fields, 1) ;
                var reg3   = simcore_native_get_field_from_ir(fields, 2) ;

                var val1 = simcore_native_get_value("BR", reg2) ;
                var val2 = simcore_native_get_value("BR", reg3) ;
                simcore_native_set_value("BR", reg1, Math.abs(val1) % Math.abs(val2)) ;

                simcore_native_go_maddr(0) ;
            }
}


#
# Register naming
#

registers
{
        0=zero,
        1=ra,
        2=sp (stack_pointer),
        3=gp,
        4=tp,
        5=t0,
        6=t1,
        7=t2,
        8=s0,
        9=s1,
        10=a0,
        11=a1,
        12=a2,
        13=a3,
        14=a4,
        15=a5,
        16=a6,
        17=a7,
        18=s2,
        19=s3,
        20=s4,
        21=s5,
        22=s6,
        23=s7,
        24=s8,
        25=s9,
        26=s10,
        27=s11,
        28=t3,
        29=t4,
        30=t5,
        31=t6
}



#
# Pseudo-instructions
# https://content.riscv.org/wp-content/uploads/2017/05/riscv-spec-v2.2.pdf
#

pseudoinstructions
{
        # nop	addi zero,zero,0	No operation
	nop
        {
            addi zero zero 0
        }

        # li rd, expression	(several expansions)	Load immediate
        li rd=reg, expression=inm
        {
            addi rd, zero, expression
        }

        # la rd, label	(several expansions)	Load address
        la rd=reg, label=inm
        {
            addi rd, zero, label
        }

        # mv rd, rs1	addi rd, rs, 0	Copy register
        mv rd=reg, rs=reg
        {
            addi rd, rs, 0
        }

        # not rd, rs1	xori rd, rs, -1	One’s complement
        not rd=reg, rs=reg
        {
            xori rd, rs, -1
        }

        # neg rd, rs1	sub rd, x0, rs	Two’s complement
        neg rd=reg, rs=reg
        {
            sub rd, zero, rs
        }

        # seqz rd, rs1	sltiu rd, rs, 1	Set if = zero
        seqz rd=reg, rs1=reg
        {
            sltiu rd, rs, 1
        }

        # snez rd, rs1	sltu rd, x0, rs	Set if ≠ zero
        snez rd=reg, rs1=reg
        {
            sltu rd, x0, rs
        }

        # sltz rd, rs1	slt rd, rs, x0	Set if < zero
        sltz rd=reg, rs1=reg
        {
            slt rd, rs, x0
        }

        # sgtz rd, rs1	slt rd, x0, rs	Set if > zero
        sgtz rd=reg, rs1=reg
        {
            slt rd, x0, rs
        }

        # beqz rs1, offset	beq rs, x0, offset	Branch if = zero
        beqz rs=reg, offset=inm
        {
            beq rs, zero, offset
        }

        # bnez rs1, offset	bne rs, x0, offset	Branch if ≠ zero
        bnez rs=reg, offset=inm
        {
            bne rs, zero, offset
        }

        # blez rs1, offset	bge x0, rs, offset	Branch if ≤ zero
        blez rs=reg, offset=inm
        {
            bge zero, rs, offset
        }

        # bgez rs1, offset	bge rs, x0, offset	Branch if ≥ zero
        bgez rs=reg, offset=inm
        {
            bge rs, zero, offset
        }

        # bltz rs1, offset	blt rs, x0, offset	Branch if < zero
        bltz rs=reg, offset=inm
        {
            blt rs, zero, offset
        }

        # bgtz rs1, offset	blt x0, rs, offset	Branch if > zero
        bgtz rs=reg, offset=inm
        {
            blt zero, rs, offset
        }

        # bgt rs, rt, offset	blt rt, rs, offset	Branch if >
        bgt rs=reg, rt=reg, offset=inm
        {
            blt rt, rs, offset
        }

        # ble rs, rt, offset	bge rt, rs, offset	Branch if ≤
        ble rs=reg, rt=reg, offset=inm
        {
            bge rt, rs, offset
        }

        # bgtu rs, rt, offset	bltu rt, rs, offset	Branch if >, unsigned
        bgtu rs=reg, rt=reg, offset=inm
        {
            bltu rt, rs, offset
        }

        # bleu rs, rt, offset	bltu rt, rs, offset	Branch if ≤, unsigned
        bleu rs=reg, rt=reg, offset=inm
        {
            bgeu rt, rs, offset
        }

        # j offset	jal x0, offset	Jump
        j offset=inm
        {
            jal zero, offset
        }

        # jal offset	jal x1, offset	Jump register
        jal offset=inm
        {
            jal ra, offset
        }

        # jr rs		jalr x0, rs, 0	Jump register
        jr rs=reg
        {
            jalr zero, rs, 0
        }

        # ret	jalr x0, x1, 0	Return from subroutine
        ret
        {
            jalr zero, ra, 0
        }
}

