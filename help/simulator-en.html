<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title></title>
	<meta charset="UTF-8">
	<meta http-equiv="Content-type" content="text/html; charset=UTF-8">
    <style type="text/css">
/*<![CDATA[*/
    :link { color: #0563C1 }
    :visited { color: #954F72 }
    p.cleanuphtml-5 {margin-bottom:8.0pt;line-height:80%}
    b.cleanuphtml-4 {font-style: italic}
    p.cleanuphtml-3 {font-weight: bold}
    p.cleanuphtml-2 {text-align: center}
    a.cleanuphtml-1 {font-weight: bold}
    /*]]>*/
    </style>

  <!-- Clean HTML generated by http://www.cleanuphtml.com/ -->
	<meta name="Generator" content="Cleanup HTML"></head>
  <body>

      <div id="help_firmware_format">
      <h1>Microcode in WepSIM</h1>

	      <p>
	      </p>
	      <p>
                The microcode is loaded through a text file you have three sections:
	      </p>
	      <p>
	        1.    List of microprograms
	      </p>
	      <p>
	        2.    Register naming
	      </p>
	      <p>
	        3.    Pseudo-instructions
	      </p>
	      <p>
                The microprograms list starts with the code of <b>fetch</b>.
                An example of basic fetch microprogram could be:
	      </p>
	      <ul>
	      <p>
	        fetch
	      </p>
	      <p>
	        {
	      </p>
	      <p>
	                fetch:    (T2, C0=1),
	      </p>
	      <p>
	                             (Ta, Td, R, BW=11, C1),
	      </p>
	      <p>
	                             (M2, C2, T1, C3),
	      </p>
	      <p>
	                             (A0, B=0, C=0000)
	      </p>
	      <p>
	        }
	      </p>
	      </ul>
	      <p class="cleanuphtml-2">
	        <a class="cleanuphtml-1" name="_Toc438322900">Figure</a> <b>11</b> <b>Example of description for</b> <b>Fetch</b>
	      </p>
	      <p>
		Control signals located between the parentheses ( and ) correspond to the signals to activate in one clock cycle. Thus the fetch requires four clock cycles, the last corresponds to decoding (included within the fetch).
	      </p>
	      <p>
		Then, the rest of microprograms associated with each instruction follows. Each microprogram has this format:
	      </p>
	      <ul>
	      <p>
	        inst1 field1 field2 field3
	      </p>
	      <p>
	        {
	      </p>
	      <p>
	                    co=000000,
	      </p>
	      <p>
	                    nwords=1,
	      </p>
	      <p>
	                    field1=reg(25,21),
	      </p>
	      <p>
	                    field2=reg(20,16),
	      </p>
	      <p>
	                    field3=reg(15,11),
	      </p>
	      <p>
	                    {
	      </p>
	      <p>
	                           (Cop=1001, SelP=11, C7, T6, LE,
	      </p>
	      <p>
	                             SelA=10100, SelB=01111, SelE=10111,
	      </p>
	      <p>
	                             A0=1, B=1, C=0)
	      </p>
	      <p>
	                    }
	      </p>
	      <p>
	        }
	      </p>
	      </ul>
	      <p class="cleanuphtml-2">
	        <a class="cleanuphtml-1" name="_Toc438322901">Figure</a> <b>12</b> <b>Example of description format for an instruction</b>
	      </p>
	      <p>
	         
	      </p>
	      <p>
		Where the first line describes the command name (inst1) and the parameters that have (registers, immediate values, etc.). Then a block opens with keys to describe the instruction.
	      </p>
	      <p>
		The first field in the example shown (co) indicates the 6 bits that uniquely identifies the instruction. This is not entirely true for arithmetic and logical instructions since it is possible to share the same opcode and as the field value cop differentiate. An example of this case would be:
	      </p>
	      <ul>
	      <p>
	         
	      </p>
	      <p>
	        inst1 field1 field2 field3
	      </p>
	      <p>
	        {
	      </p>
	      <p>
	                    co=000000,
	      </p>
	      <p class="cleanuphtml-3">
	                    cop=0000,
	      </p>
	      <p>
	                    nwords=1,
	      </p>
	      <p>
	                    field1=reg(25,21),
	      </p>
	      <p>
	                    field2=reg(20,16),
	      </p>
	      <p>
	                    field3=reg(15,11),
	      </p>
	      <p>
	                    {
	      </p>
	      <p>
	                           (Cop=1001, SelP=11, C7, T6, LE,
	      </p>
	      <p>
	                             SelA=10100, SelB=01111, SelE=10111,
	      </p>
	      <p>
	                             A0=1, B=1, C=0)
	      </p>
	      <p>
	                    }
	      </p>
	      <p>
	        }
	      </p>
	      </ul>
	      <p class="cleanuphtml-2">
	        <a class="cleanuphtml-1" name="_Toc438322902">Figure</a> <b>13</b> <b>Detail in the description of an instruction: field cop</b>
	      </p>
	      <p>
	        <br />
		The following fields indicate for each of the parameters what type (registration, immediately or address) as well as the start and end bit among which is the value of that parameter.
	      </p>
	      <p>
		The parameter type is indicated by:
	      </p>
<ul>
	      <li>
	        parameter1 = reg(bit-inicio, bit-final): for a register.
	      </li>
	      <li>
	        parameter1 = inm(bit-inicio, bit-final): for an immediate value.
	      </li>
	      <li>
	        parameter1 = addr(bit-inicio, bit-final)rel: for a relative address.
	      </li>
	      <li>
	        parameter1 = addr(bit-inicio, bit-final)abs: for an absolute address.
	      </li>
</ul>
	      <p>
		Then, a new block is open where the microprogram for the instruction is described. The signals of each cycle are in parentheses and such cycles are separated by commas. If there is only one cycle then it is not necessary the comma. Within the parentheses the signs and the corresponding value is indicated. A only-bit signal can be expressed just by the name of the signal (it means that its value is one). The value of the signal should indicate in binary, using as many bits as the signal has. Signals and their corresponding value are separated using a comma.
	      </p>
	      <p>
		Register naming requires the label to be used for each of the 32 registers of the register file. An example of this section is:<br />
	        <br />
	      </p>
	      <ul>
	      <p>
	        registers
	      </p>
	      <p>
	        {
	      <br>
	                  0=$zero,
	      <br>
	                  1=$at,
	      <br>
	                  2=$v0,
	      <br>
	                  3=$v1,
	      <br>
	                  4=$a0,
	      <br>
	                  5=$a1,
	      <br>
	                  6=$a2,
	      <br>
	                  7=$a3,
	      <br>
	                  .
	      <br>
	                  .
	      <br>
	                  .
	      <br>
	                  24=$t8,        
	      <br>
	                  25=$t9,
	      <br>
	                  26=$k0,
	      <br>
	                  27=$k1,
	      <br>
	                  28=$gp,
	      <br>
	                  29=$sp (stack_pointer),
	      <br>
	                  30=$fp,
	      <br>
	                  31=$ra
	      <br>
	        }
	      </p>
	      </ul>
	      <p class="cleanuphtml-2">
	        <a class="cleanuphtml-1" name="_Toc438322903">Figure</a> <b>14</b> <b>Example of register naming</b>
	      </p>
	      <p>
	        <br />
		In the last example, the names used where the MIPS32 architecture names. In this example the register 29 labeled with $ sp has the attribute "(stack_pointer)" to indicate that will be used as a the stack pointer.
	      </p>
	      <p>
	         
	      </p>
	      <p>
		Finally you can define pseudo-instructions.
		An example would pseudoinstruction:
	      </p>
	      <ul>
	      <p>
	        Pseudoinstructions<br />
	        {<br />
	                li reg num<br />
	                {<br />
	                       lui reg sel(31,16,num) ;<br />
	                       ori reg reg sel(15,0,num)<br />
	                 }<br />
	        }
	      </p>
	      <p>
	         
	      </p>
	      </ul>
	      <p class="cleanuphtml-2">
	        <a class="cleanuphtml-1" name="_Toc438322904">Figure</a> <b>15</b> <b>Example of pseudo-instruction (optional section)</b>
	      </p>
	      <p>
	        <br />
		Where the "sel (bit-start, bit-end field)" operator allows us to select a number of bits of one of the fields from the pseudo-instruction.
	      </p>
	      <p>
	         
	      </p>

      </div>


      <div id="help_assembly_format">
      <h1>Assembler in WepSIM</h1>

	      <p>
	      </p>
	      <p>
                The assembly code is described in a text file with a first data section (.data) and a second section with the code (.text)<br />
	        <br />
		In the data section it is possible to define the variables and constants that will stay in the data segment of main memory. The section begins with the <i>.data</i> directive. The directives that specify the types of data that can be defined are:
	      </p>
	      <p>
	        &middot;       <b>.ascii:</b> Is followed by a string, instructing the assembler to create a memory area with data, and store in it the indicated string.
	      </p>
	      <p>
	        &middot;       <b>.asciiz:</b> Is followed by a string, instructing the assembler to create a memory area with data, and store the associated string as a null terminated string.
	      </p>
	      <p>
	        &middot;       <b>.byte:</b> Is followed by one or more values that form part of the value of the variable. If multiple values, these values are separated by comma. The values that can be used are: <b>character, octal, hexadecimal, and decimal</b>.
	      </p>
	      <p>
	        &middot;       <b>.half:</b> Is followed by one or more values that form part of the value of the variable. If multiple values, these values are separated by comma. The values that can be used are: <b>octal, hexadecimal, and decimal</b>.
	      </p>
	      <p>
	        &middot;       <b>.word:</b> Is followed by one or more values that form part of the value of the variable. If multiple values, these values are separated by comma. The values that can be used are: <b>octal, hexadecimal, and decimal</b>.
	      </p>
	      <p>
	        &middot;       <b>.space:</b> It is followed by the number of bytes in decimal format that the user wants to allocate.
	      </p>
	      <p>
                The format of a value of the former data types is:
	      </p>
	      <p>
	        &middot;       <b>String:</b> character sequence enclosed in double quotes.<br />
	        For example: "hola 123\n"
	      </p>
	      <p>
	        &middot;       <b>Character:</b> character surrounded by simple quotes.<br />
	        For example: &apos;c&apos;.
	      </p>
	      <p>
	        &middot;       <b>Octal:</b> a number starting with zero and its digits are lower than eight. 
               For example: 012.
	      </p>
	      <p>
	        &middot;       <b>Hexadecimal:</b> a number that begins with the 0x prefix and its digits are zero through nine and the letters a, b, c, d, e, and f.<br />
	        For example: 0x12.
	      </p>
	      <p>
	        &middot;       <b>Decimal:</b> a number that is not in octal or hexadecimal, and its digits fall between zero and nine (inclusive).<br />
	        For example: 12.
	      </p>
	      <p>
		In the code section you can define subroutines staying in the code segment of main memory. The section begins with <i>.text<i> directive.
	      </p>
	      <p>
	         
	      </p>
	      <p>
		You can use line comments using the # character.<br />
		Everything that follows this character to the end of line will be ignored by the assembler.
	      </p>
	      <p>
	        An example program would be:
	      </p>
	      <ul>
	      <p>
	        .data
	      </p>
	      <p>
	                  age1:    .word   0x12345678, 20     
	      </p>
	      <p>
	                  age2:    .word   20 , 10
	      </p>
	      <p>
	                  resultado: .word 0
	      </p>
	      <p>
	                  # 32-bit word initialized with decimal
	      </p>
	      <p>
	                  texto: .ascii "Hola\t"
	      </p>
	      <p>
	                  texto2: .asciiz "Hola\t"
	      </p>
	      <p>
	                  hueco: .space 16
	      </p>
	      <p>
	        .text
	      </p>
	      <p>
	        .globl main
	      </p>
	      <p>
	        main:  li $3 2
	      </p>
	      <p>
	                   li $4 1
	      </p>
	      <p>
	                   li $5 0<br />
	        <br />
	      </p>
	      </ul>
	      <p class="cleanuphtml-2">
	        <a class="cleanuphtml-1" name="_Toc438322908">Figure</a> <b>19</b> <b>Example of data and code sections to test micro-aassemblies. </b><b><br />
	        <br /></b>
	      </p>

      </div>


      <div id="help_simulator_arch">
      <h1>WepSIM architecture</h1>

	      <p> </p>
	      <p>
 	        The whole simulated system (see <b class="cleanuphtml-1">Figure 1</b>) includes the processor, a 1 MB memory module (addressed at byte level), a keyboard, a display, and a I/O devices that can generate interruptions.
	      </p>
	      <p>
	      </p>
	      <p>
	        <img max-width="90%" width="90%" id="Imagen 2" src="help/simulator/simulator001.jpg" alt="" name="Imagen 2" />
	      </p>
	      <p class="cleanuphtml-3">
	        <a name="_Toc438322890"></a><a class="cleanuphtml-2" name="_Ref434141389">Figure</a> <b>1</b> <b>Full system</b>
	      </p>
	      <p>
	      </p>
	      <p>
                The processor (see <b class="cleanuphtml-1">Figure 2</b>) is 32 bits CPU that works with up to 64 definable user instructions (MIPS style, ARM style, etc.), and it has a register file of 32 registers, with port-mapped I/O (isolated I/O).
	      </p>
	      <p>
	      </p>
	      <p class="cleanuphtml-3">
	        <img max-width="90%" width="90%" id="Imagen 9" src="help/simulator/simulator002.jpg" alt="" name="Imagen 9" />
	      </p>
	      <p class="cleanuphtml-3">
	        <a name="_Toc438322891"></a><a class="cleanuphtml-2" name="_Ref434142801">Figure</a> <b>2</b> <b>WepSIM processor</b>
	      </p>
	      <p>
	      </p>
	      <p>
		The processor uses 32-bit addresses, using the address bus (<i>Address Bus</i>) for address and data bus (<i>Data Bus</i>) to send/receive data to/from memory.
	      </p>
	      <p>
	         
	      </p>
	      <p>
		The processor waits for a memory cycle to perform the read operation (activated with the R signal) or the write operation (activated with the W signal).
	      </p>
	      <p>
	         
	      </p>
	      <p>
	        The main memory uses <i>Little-Endian</i> as shown in the <b class="cleanuphtml-1">Figure 3</b>.
	      </p>
	      <p>
	         
	      </p>
	      <p class="cleanuphtml-3">
	        <img max-width="90%" width="90%" id="Imagen 22" src="help/simulator/simulator003.jpg" alt="" name="Imagen 22" />
	      </p>
	      <p class="cleanuphtml-3">
	         
	      </p>
	      <p class="cleanuphtml-3">
	        <a name="_Toc438322892"></a><a class="cleanuphtml-2" name="_Ref434149687">Figure</a> <b>3</b> <b>Byte arrangement in memory.</b>
	      </p>
	      <p>
	         
	      </p>
	      <p>
                Therefore the least significant byte is at the lowest memory address.
	      </p>
	      <p>
	         
	      </p>
	      <p>
      		The memory access is performed at byte-level.
	      </p>
	      <p>
    		For byte selection is required on the one hand indicate the direction of the word where you are (A<sub>31</sub>...A<sub>2</sub>00), and on the other hand the byte within that word that you want to access (BE<sub>3</sub>...BE<sub>0</sub>).
	      </p>
	      <p>
	         
	      </p>
	      <p class="cleanuphtml-3">
	        <img max-width="90%" width="90%" id="Imagen 24" src="help/simulator/simulator004.jpg" alt="" name="Imagen 24" />
	      </p>
	      <p class="cleanuphtml-3">
	        <a name="_Toc438322893"></a><a class="cleanuphtml-2" name="_Ref434150369">Figure</a> <b>4</b> <b>Memoria module</b>
	      </p>
	      <p>
	         
	      </p>
	      <p>
	        The <b class="cleanuphtml-1">Figure 4</b> shows these inputs/outputs mentioned, which is necessary to join the R and W request signals for read and write respectively.
	      </p><br clear="all" />
	      <p>
	         
	      </p>
	      <h2>
	        <a name="_Toc438325788">Internal organization: control signals</a>
	      </h2>
	      <p>
	         
	      </p>
	      <p>
		The control unit in WepSIM is a microprogrammable one. The Control Memory has 4096 micro-words with 76 bits each one (see <b class="cleanuphtml-1">Figure 5</b>).
	      </p>
	      <p class="cleanuphtml-3">
	        <img max-width="90%" width="90%" id="Imagen 12" src="help/simulator/simulator005.jpg" alt="" name="Imagen 12" />
	      </p>
	    <br clear="all" />
	    <div class="WordSection2"></div>
	    <br clear="all" />
	    <div class="WordSection3">
	      <p class="cleanuphtml-3">
	        <a name="_Toc438322894"></a><a class="cleanuphtml-2" name="_Ref434141431">Figure</a> <b>5</b> <b> microinstruction format</b>
	      </p>
	      <p>
                The general nomenclature used to name the control signals is:
	      </p>
	      <p>
	        ·       Cx: signal for loading data into the register X
	      </p>
	      <p>
	        ·       Tx: tristate activation signal for X
	      </p>
	      <p>
	        ·       Ry: register identification for the output value in register y
	      </p>
	      <p>
	        ·       Mx: multiplexer X selection value
	      </p>
	      <p>
		Additionally, the LE signal indicates updating the register file, Cop indicates the operation to be performed in the ALU, Selp selects which bits will be updated on the status register (SR), A1A0 are the two least significant bits of a memory address, and BW allows us to specify the size of the data that is accessed in memory: a complete word, a half-word, or a byte.
	      </p>
	      <p>
	         
	      </p>
	      <p>
		The processor (see <b class="cleanuphtml-1">Figure 6</b>) can be considered divided into 7 parts: memory access (MAR, MBR, etc.), program counter register management (PC, etc.), instruction register management (IR, etc. .), control unit (control unit), register bank (register File), ALU and management of the status register (SR, etc.).
	      </p>
	      <p>
	        <img max-width="90%" width="90%" id="Imagen 5" src="help/simulator/simulator006.jpg" alt="" name="Imagen 5" />
	      </p>
	      <p class="cleanuphtml-3">
	        <a name="_Toc438322895"></a><a class="cleanuphtml-2" name="_Ref434141629">Figure</a> <b>6</b> <b>Processor in details</b>
	      </p>
	      <p>
	        <br />
		The control unit (see  <b class="cleanuphtml-1">Figure 7</b>) is divided into five parts: control of the following microaddress (MUX A, etc.), the transformation of the opcode to the corresponding microaddress (co2uAddr), control of the conditional selection of microaddress (MUX B, MUX C, etc.), the control memory with the microinstruction register and finally selectors RA, RB, RE and Cop.
	      </p>
	      <p>
	        <img max-width="90%" width="90%" id="Imagen 7" src="help/simulator/simulator007.jpg" alt="" name="Imagen 7" />
	      </p>
	      <p class="cleanuphtml-3">
	        <a name="_Toc438322896"></a><a class="cleanuphtml-2" name="_Ref434141950">Figure</a> <b>7</b> <b>Control unit details.</b>
	      </p>
	      <p>
		To address the control memory, 12 bits are required with implicit sequencing. You can specify as control memory microaddress (see <b class= "cleanuphtml-1">Figure 8</b>) the next memory position, or using part of the microinstruction, or use the output of a translation module (with the starting microaddress associated with an operation code), or zero microaddress (0) from where the fetch begins.
	      </p>
	      <p class="cleanuphtml-3">
	        <img max-width="90%" width="90%" id="Imagen 11" src="help/simulator/simulator008.jpg" alt="" name="Imagen 11" />
	      </p>
	      <p class="cleanuphtml-3">
	        <a name="_Toc438322897"></a><a class="cleanuphtml-2" name="_Ref434143860">Figure</a> <b>8</b> <b>Options for the MUX A</b>
	      </p>
	      <p class="cleanuphtml-4"></p>
	      <p class="cleanuphtml-4"></p>
	    </div>

      </div>


      <div id="help_simulator_screens">
      <h1>Execution in WepSIM</h1>

	      <p>
	      </p>
	      <p>
	        El ciclo de trabajo supone (normalmente) los siguientes pasos:
		<ul>
                <li>Cargar un firmware de trabajo (ver Gesti&oacute;n de microc&oacute;digo).</li>
                <li>Cargar un programa en ensamblador que use el firmware de trabajo (ver Gesti&oacute;n del ensamblador).</li>
		<li>Ir a la pantalla principal (simulador) para ejecutar el programa en ensamblador que use el firmware de trabajo (ver Simulaci&oacute;n en WepSIM).</li>
		</ul>
	      </p>
	      <p>
	      </p>


	      <a name="firmware_screens"></a>
              <h2>Gesti&oacute;n de microc&oacute;digo en WepSIM</h2>

	      <p>
	        Un fichero de texto con las tres secciones antes comentadas
                (microc&oacute;digo, nombrado de registro y definici&oacute;n de pseudo-instrucciones) se carga en la pantalla de Firmware. Para acceder a dicha
	        pantalla se ha de ir al men&uacute; (parte superior derecha) e indicar la opci&oacute;n <i>Firmware</i> (v&eacute;ase la <b class="cleanuphtml-4">Figure 16</b>)
	      </p>
	      <p>
	         
	      </p>
	      <p>
	        <img max-width="90%" width="90%" id="Imagen 1" src="help/simulator/firmware001.jpg" alt="" name="Imagen 1" />
	      </p>
	      <p class="cleanuphtml-2">
	        <a name="_Ref434190846"></a><a name="_Toc438322905"></a><a class="cleanuphtml-1" name="_Ref434190877">Figure</a> <b>16</b> <b>Pantalla principal: opci&oacute;n de carga de firmware</b>
	      </p>
	      <p>
	        <br />
	        A continuaci&oacute;n aparecer&aacute; una pantalla con un cuadro de texto que permite indicar el <i>firmware</i> (las tres secciones antes comentadas). Es posible cargar un <i>firmware</i> existente
	        usando el bot&oacute;n "Load" de la barra inferior, modificar un <i>firmware</i> anteriormente cargado o salvar el firmware en curso con el bot&oacute;n "Save" de la barra inferior. Una vez se indique el
	        firmware es preciso hacer clic en el bot&oacute;n "&#181;compile" para pasar a binario y cargar en la memoria de control dicho firmware, como se muestra en la <b class="cleanuphtml-4">Figure 17</b>.
	      </p>
	      <p>
	        <img max-width="90%" width="90%" id="Imagen 2" src="help/simulator/firmware002.jpg" alt="" name="Imagen 2" />
	      </p>
	      <p class="MsoNormal cleanuphtml-5"></p>
	      <table cellpadding="0" cellspacing="0" align="left">
	      </table> <br clear="all" />
	      <p class="cleanuphtml-2">
	        <a name="_Toc438322906"></a><a class="cleanuphtml-1" name="_Ref434191423">Figure</a> <b>17</b> <b>Pantalla firmware: cuadro de texto con firmware a cargar</b>
	      </p>
	      <p>
	        <br />
	        Una vez cargado el nuevo <i>firmware</i> correctamente aparecer&aacute; la pantalla mostrada en la <b class="cleanuphtml-4">Figure 18</b> en la que se muestra la memoria de control con los valores
	        que almacena.
	      </p>
	      <p>
	        <img max-width="90%" width="90%" id="Imagen 3" src="help/simulator/firmware004.jpg" alt="" name="Imagen 3" />
	      </p>
	      <p class="cleanuphtml-2">
	        <a name="_Toc438322907"></a><a class="cleanuphtml-1" name="_Ref434191551">Figure</a> <b>18</b> <b>Pantalla firmware: firmware finalmente compilado</b>
	      </p>
	      <p>
	        <br />
	        El siguiente paso es la carga del programa ensamblador que permita probar este <i>firmware</i>, para ello podemos pulsar el bot&oacute;n "<i>Assembly</i>" de la barra inferior.
	      </p>
	      <p>
	         
	      </p>


	      <a name="assembly_screens"></a>
              <h2>Gesti&oacute;n del ensamblador en WepSIM</h2>

	      <p>
	        Un fichero de texto con las dos secciones antes comentadas
                (datos y c&oacute;digo) se carga en la pantalla de Ensamblador. Para acceder a dicha pantalla se ha de ir al men&uacute; (parte superior derecha)
	        e indicar la opci&oacute;n Assembly (v&eacute;ase la <b class="cleanuphtml-3">Figure 16</b>)<br />
	        <br />
	      </p>
	      <p>
	        <img max-width="90%" width="90%" id="Imagen 3" src="help/simulator/assembly002.jpg" alt="" name="Imagen 3" />
	      </p>
	      <p class="cleanuphtml-2">
	        <a name="_Toc438322909"></a><a class="cleanuphtml-1" name="_Toc434155501">Figure</a> <b>20</b> <b>Pantalla principal: opci&oacute;n de carga de c&oacute;digo ensamblador</b>
	      </p>
	      <p>
	        A continuaci&oacute;n aparecer&aacute; una pantalla con un cuadro de texto que permite indicar el c&oacute;digo en ensamblador. Es posible cargar un c&oacute;digo existente usando el bot&oacute;n "Load" de la barra superior,
	        modificar un c&oacute;digo anteriormente cargado o salvar el c&oacute;digo actualmente en cargado con el bot&oacute;n "Save" de la barra inferior.
	      </p>
	      <p>
	        Una vez se indique el c&oacute;digo es preciso hacer clic en el bot&oacute;n "Compile" para pasar a binario y cargar en la memoria de principal el binario resultante, 
		tal y como se muestra en la <b class="cleanuphtml-3">Figure 21</b>. 
	      </p>
	      <p>
	         
	      </p>
	      <p>
	        <img max-width="90%" width="90%" id="Imagen 28" src="help/simulator/assembly003.jpg" alt="" name="Imagen 28" />
	      </p>
	      <p class="cleanuphtml-2">
	        <a name="_Toc438322910"></a><a class="cleanuphtml-1" name="_Ref434192102">Figure</a> <b>21</b> <b>Pantalla ensamblador: cuadro de texto con ensamblador a cargar</b><b><br />
	        <br /></b>
	      </p>
	      <p>
	        Una vez compilado, se pasar&aacute; a la pantalla indicada en la <b class="cleanuphtml-3">Figure 23</b>, donde se mostrar&aacute; el contenido de la memoria principal en binario.
	      </p>
	      <p>
	         
	      </p>
	      <p>
	        <img max-width="90%" width="90%" id="Imagen 30" src="help/simulator/assembly005.jpg" alt="" name="Imagen 30" />
	      </p>
	      <p class="cleanuphtml-2">
	        <a name="_Toc438322912"></a><a class="cleanuphtml-1" name="_Ref434192450">Figure</a> <b>23</b> <b>Pantalla ensamblador: c&oacute;digo finalmente compilado</b>
	      </p>
	      <p>
	        <br />
	        El siguiente paso es ir a la pantalla principal para ejecutar la combinaci&oacute;n de <i>firmware</i> y ensamblador cargado, para lo que ha de pulsar el bot&oacute;n "Simulador" de la barra inferior.
	      </p>
	      <p>
	      </p>


	      <a name="simulator_screens"></a>
              <h2>Simulaci&oacute;n en WepSIM</h2>

	      <p>
	        Estando en la pantalla principal es posible visualizar:
	      </p>
	      <ul>
	      <li>
	        El contenido de la memoria de control (v&eacute;ase la <b>Figure 24</b>), con las se&ntilde;ales que est&aacute;n asociadas a cada ciclo. Para ello ha de pulsar el bot&oacute;n "<i>Control Memory</i>" en
	        la barra de botones situada en la parte superior derecha de la pantalla principal.<br />
	        Se destaca las se&ntilde;ales que en el presente ciclo de reloj est&aacute;n activadas en azul con letra algo m&aacute;s grande.<br />
	        Se dispone de una barra de desplazamiento para poder inspeccionar todo el contenido de la memoria de control.
	      </li>
	      <li>
	        El contenido de la memoria principal (v&eacute;ase la <b class="cleanuphtml-1">Figure 25</b>), con las instrucciones en ensamblador a ejecutar. Para estas, es posible establecer un punto de
	        ruptura haciendo clic en la columna <i>breakpoints</i>. Al establecer un punto de ruptura aparecer&aacute; un icono en dicha columna.
	      </li>
	      </ul>
	      <p>
	        <img             id="Imagen 1" src="help/simulator/simulator009.jpg" alt="" name="Imagen 1" />
	      </p>
	      <p class="cleanuphtml-3">
	        <a name="_Toc438322913"></a><a class="cleanuphtml-2" name="_Ref434192973">Figure</a> <b>24</b> <b>Pantalla principal: visualizaci&oacute;n de la memoria de control</b>
	      </p>
	      <p>
	      </p>
	      <p>
	        <img             id="Imagen 3" src="help/simulator/simulator010.jpg" alt="" name="Imagen 3" />
	      </p>
	      <p class="cleanuphtml-3">
	        <a name="_Toc438322914"></a><a class="cleanuphtml-2" name="_Ref434193222">Figure</a> <b>25</b> <b>Pantalla principal: visualizaci&oacute;n del c&oacute;digo en la memoria principal</b>
	      </p>
	      <p>
	      </p>
	      <p>
	        Estando en la pantalla principal es posible ejecutar:
	      </p>
	      <p>
	        ·       Microinstrucci&oacute;n a microinstrucci&oacute;n pulsando el bot&oacute;n "µInstrucci&oacute;n" (v&eacute;ase la <b class="cleanuphtml-1">Figure 26</b>), de forma que se pasar&aacute; al siguiente ciclo de reloj y se
	        generar&aacute;n las se&ntilde;ales de control asociadas.
	      </p>
	      <p>
	        ·       Instrucci&oacute;n a instrucci&oacute;n pulsando el bot&oacute;n "Instrucci&oacute;n" (v&eacute;ase la <b class="cleanuphtml-1">Figure 26</b>) de forma que se generar&aacute;n todos los ciclos de reloj asociados al
	        microprograma de la instrucci&oacute;n, parando al principio del <i>fetch</i>.
	      </p>
	      <p>
	      </p>
	      <p>
	        <img             id="Imagen 4" src="help/simulator/simulator011.jpg" alt="" name="Imagen 4" />
	      </p>
	      <p class="cleanuphtml-3">
	        <a name="_Toc438322915"></a><a class="cleanuphtml-2" name="_Ref434193775">Figure</a> <b>26</b> <b>Pantalla principal: opciones para la ejecuci&oacute;n</b>
	      </p>
	      <p>
	        <br />
	        Dando al bot&oacute;n "<i>Registers</i>" en la barra de botones situada en la parte superior derecha de la pantalla principal (v&eacute;ase la <b class="cleanuphtml-1">Figure 26</b>) es posible ver c&oacute;mo
	        los valores de los registros son modificados durante la ejecuci&oacute;n.
	      </p>
	      <p>
	        Es posible visualizar tambi&eacute;n la unidad de control como se muestra en la <b class="cleanuphtml-1">Figure 27</b>.
	      </p>
	      <p>
	      </p>
	      <p>
	        <img             id="Imagen 8" src="help/simulator/simulator012.jpg" alt="" name="Imagen 8" />
	      </p>
	      <p class="cleanuphtml-3">
	        <a name="_Toc438322916"></a><a class="cleanuphtml-2" name="_Ref434194139">Figure</a> <b>27</b> <b>Pantalla principal: visualizaci&oacute;n de la unidad de control</b>
	      </p>
	      <p>
	        As&iacute; como tambi&eacute;n es posible reiniciar la ejecuci&oacute;n haciendo clic al bot&oacute;n "Reset" situado en la barra de botones que aparece en la parte superior de la pantalla.
	      </p>
	      <p>
	      </p>
	      <p>
	      </p>

      </div>

  </body>
</html>
